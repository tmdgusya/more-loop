#!/usr/bin/env bash
set -euo pipefail

# multi-loop — Universal multi-provider parallel runner via tmux
# Reads provider definitions from providers.json and spawns parallel
# tmux windows, each running its own CLI against the same spec.

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Defaults
PROVIDERS=""
SESSION_NAME="multi-loop"
CONFIG_FILE=""
PASSTHROUGH_ARGS=()
PROMPT_FILE=""
VERIFY_FILE=""
DRY_RUN=false
STATUS_MODE=false
STOP_MODE=false
INIT_MODE=false
WEB_MODE=false
PORT_BASE=8080

usage() {
  cat <<'EOF'
Usage: multi-loop [OPTIONS] <prompt-file> [verify-file]
       multi-loop --status [prompt-file]
       multi-loop --stop [prompt-file]
       multi-loop --init

Universal multi-provider parallel runner via tmux.
Reads provider definitions from providers.json and spawns parallel
tmux windows, each running its own CLI against the same spec.

Arguments:
  prompt-file             Spec/prompt describing what to build
  verify-file             Verification plan (.sh or .md)

Options:
  --providers LIST        Comma-separated providers to run (default: all in config)
  --config FILE           Path to providers.json (default: auto-detect)
  --session NAME          tmux session name (default: multi-loop)
  --dry-run               Show what would run without executing
  --status                Show status of all running providers
  --stop                  Stop all providers in the session
  --init                  Generate default providers.json in current directory
  -w, --web               Enable web dashboards (auto-port per provider)
  --port-base PORT        Base port for web dashboards (default: 8080)
  -h, --help              Show help

Passthrough options (forwarded to more-loop providers):
  -n, --iterations N      Max iterations
  -m, --model MODEL       Model override
  -v, --verbose           Verbose output
  --oracle                Enable Oracle phase
  --approve               Enable approval mode
  --approve-every         Approve after every iteration
  --approve-timeout N     Approval timeout in seconds
  --max-tasks N           Max tasks in bootstrap

Config search order:
  1. --config flag
  2. ./multi-loop.json (current directory)
  3. ./providers.json (current directory)
  4. ~/.config/multi-loop/providers.json (user default)
  5. <script-dir>/providers.json (bundled default)

Examples:
  # Run all providers with 10 iterations
  multi-loop -n 10 prompt.md verify.sh

  # Run only GLM and Claude
  multi-loop --providers glm,claude -n 8 prompt.md

  # With web dashboards (check from phone)
  multi-loop -w -n 10 prompt.md verify.sh

  # Use custom config
  multi-loop --config my-providers.json -n 5 prompt.md

  # Check status / stop
  multi-loop --status
  multi-loop --stop
EOF
}

log() { echo -e "${BLUE}${BOLD}$1${NC}" >&2; }
log_pass() { echo -e "${GREEN}$1${NC}" >&2; }
log_fail() { echo -e "${RED}$1${NC}" >&2; }
log_warn() { echo -e "${YELLOW}$1${NC}" >&2; }

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --providers)    PROVIDERS="$2"; shift 2 ;;
      --config)       CONFIG_FILE="$2"; shift 2 ;;
      --session)      SESSION_NAME="$2"; shift 2 ;;
      --dry-run)      DRY_RUN=true; shift ;;
      --status)       STATUS_MODE=true; shift ;;
      --stop)         STOP_MODE=true; shift ;;
      --init)         INIT_MODE=true; shift ;;
      -w|--web)       WEB_MODE=true; shift ;;
      --port-base)    PORT_BASE="$2"; shift 2 ;;
      -h|--help)      usage; exit 0 ;;
      # Passthrough: key-value args
      -n|--iterations|-m|--model|--approve-timeout|--max-tasks)
        PASSTHROUGH_ARGS+=("$1" "$2"); shift 2 ;;
      # Passthrough: flag args
      -v|--verbose|--oracle|--approve|--approve-every)
        PASSTHROUGH_ARGS+=("$1"); shift ;;
      -*)
        log_fail "Unknown option: $1"
        usage >&2; exit 1 ;;
      *)
        if [[ -z "$PROMPT_FILE" ]]; then
          PROMPT_FILE="$1"
        elif [[ -z "$VERIFY_FILE" ]]; then
          VERIFY_FILE="$1"
        else
          log_fail "Unexpected argument: $1"
          exit 1
        fi
        shift ;;
    esac
  done
}

# Find config file using search order
find_config() {
  if [[ -n "$CONFIG_FILE" ]]; then
    if [[ ! -f "$CONFIG_FILE" ]]; then
      log_fail "Config file not found: $CONFIG_FILE"
      exit 1
    fi
    echo "$CONFIG_FILE"
    return
  fi

  local candidates=(
    "./multi-loop.json"
    "./providers.json"
    "${HOME}/.config/multi-loop/providers.json"
    "${SCRIPT_DIR}/providers.json"
  )

  for candidate in "${candidates[@]}"; do
    if [[ -f "$candidate" ]]; then
      echo "$candidate"
      return
    fi
  done

  log_fail "No providers.json found. Run 'multi-loop --init' to create one."
  exit 1
}

# Read provider config via python3
# Usage: read_provider_field <config_file> <provider_name> <field>
read_provider_field() {
  local config="$1" provider="$2" field="$3"
  python3 -c "
import json, sys
d = json.load(open(sys.argv[1]))
p = d.get('providers', {}).get(sys.argv[2], {})
val = p.get(sys.argv[3], '')
if isinstance(val, dict):
    # env dict: output as export statements
    for k, v in val.items():
        print(f'export {k}=\"{v}\"')
elif isinstance(val, list):
    # unset list: output as unset statements
    for k in val:
        print(f'unset {k} 2>/dev/null || true')
else:
    print(val)
" "$config" "$provider" "$field" 2>/dev/null
}

# List all provider names from config
list_providers() {
  local config="$1"
  python3 -c "
import json, sys
d = json.load(open(sys.argv[1]))
for name in d.get('providers', {}):
    print(name)
" "$config" 2>/dev/null
}

# Generate default providers.json
init_config() {
  local target="./providers.json"
  if [[ -f "$target" ]]; then
    log_warn "providers.json already exists. Overwrite? [y/N]"
    read -r answer
    if [[ "$answer" != "y" && "$answer" != "Y" ]]; then
      log "Aborted."
      exit 0
    fi
  fi

  cp "${SCRIPT_DIR}/providers.json" "$target"
  log_pass "Created providers.json with default providers (glm, kimi, claude, codex, opencode)"
  log "Edit this file to add/remove providers or change settings."
}

# Build the shell command for a provider
build_provider_command() {
  local config="$1" provider="$2" prompt="$3" verify="$4"

  # 1. Setup command (optional)
  local setup
  setup="$(read_provider_field "$config" "$provider" "setup")"
  if [[ -n "$setup" ]]; then
    echo "$setup"
  fi

  # 2. Env vars
  local env_cmds
  env_cmds="$(read_provider_field "$config" "$provider" "env")"
  if [[ -n "$env_cmds" ]]; then
    echo "$env_cmds"
  fi

  # 3. Unset vars
  local unset_cmds
  unset_cmds="$(read_provider_field "$config" "$provider" "unset")"
  if [[ -n "$unset_cmds" ]]; then
    echo "$unset_cmds"
  fi

  # 4. Command template with variable substitution
  local cmd_template
  cmd_template="$(read_provider_field "$config" "$provider" "command")"

  local args_str="${PASSTHROUGH_ARGS[*]:-}"

  # Add web mode args for more-loop based providers
  if [[ "$WEB_MODE" == true ]] && echo "$cmd_template" | grep -q "more-loop"; then
    local port=$((PORT_BASE + PROVIDER_PORT_OFFSET))
    args_str="$args_str -w --port $port"
  fi

  # Substitute template variables
  cmd_template="${cmd_template//\{args\}/$args_str}"
  cmd_template="${cmd_template//\{prompt\}/\"$prompt\"}"
  if [[ -n "$verify" ]]; then
    cmd_template="${cmd_template//\{verify\}/\"$verify\"}"
  else
    cmd_template="${cmd_template//\{verify\}/}"
  fi

  echo "$cmd_template"
}

# Show status of all running providers
show_status() {
  local config
  config="$(find_config)"

  echo "" >&2
  printf "${BOLD}%-12s %-15s %-8s %-12s${NC}\n" "Provider" "Phase" "Iter" "Tasks" >&2
  echo "───────────────────────────────────────────────────" >&2

  local found=false

  for state_file in .more-loop/*/state.json; do
    [[ -f "$state_file" ]] || continue
    found=true

    python3 -c "
import json, sys
d = json.load(open(sys.argv[1]))
name = d.get('run_name', '?')
phase = d.get('phase', '?')
ci = d.get('current_iteration', '?')
mi = d.get('max_iterations', '?')
tc = d.get('tasks_completed', '?')
tt = d.get('tasks_total', '?')
print(f'{name:<12} {phase:<15} {ci}/{mi:<5} {tc}/{tt}')
" "$state_file" >&2 2>/dev/null || true
  done

  if [[ "$found" == false ]]; then
    echo "  No active runs found." >&2
  fi
  echo "" >&2
}

# Stop all providers
stop_all() {
  # Send stop signal to all more-loop run dirs
  for run_dir in .more-loop/*/; do
    [[ -d "$run_dir" ]] || continue
    touch "${run_dir}/.signal-stop"
    log "Stop signal sent to ${run_dir}"
  done

  # Kill tmux session
  if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    tmux kill-session -t "$SESSION_NAME"
    log "Killed tmux session: $SESSION_NAME"
  fi
}

# Launch all providers in tmux
launch() {
  if [[ -z "$PROMPT_FILE" ]]; then
    log_fail "Error: prompt-file is required"
    usage >&2; exit 1
  fi
  if [[ ! -f "$PROMPT_FILE" ]]; then
    log_fail "Error: prompt file not found: $PROMPT_FILE"
    exit 1
  fi
  if [[ -n "$VERIFY_FILE" && ! -f "$VERIFY_FILE" ]]; then
    log_fail "Error: verify file not found: $VERIFY_FILE"
    exit 1
  fi
  if ! command -v tmux &>/dev/null; then
    log_fail "Error: tmux is required but not found"
    exit 1
  fi

  local config
  config="$(find_config)"
  log "Config: $config"

  # Determine provider list
  local -a provider_list
  if [[ -n "$PROVIDERS" ]]; then
    IFS=',' read -ra provider_list <<< "$PROVIDERS"
  else
    while IFS= read -r p; do
      provider_list+=("$p")
    done < <(list_providers "$config")
  fi

  if [[ ${#provider_list[@]} -eq 0 ]]; then
    log_fail "No providers found in config"
    exit 1
  fi

  # Resolve absolute paths
  local prompt_abs verify_abs=""
  prompt_abs="$(cd "$(dirname "$PROMPT_FILE")" && pwd)/$(basename "$PROMPT_FILE")"
  if [[ -n "$VERIFY_FILE" ]]; then
    verify_abs="$(cd "$(dirname "$VERIFY_FILE")" && pwd)/$(basename "$VERIFY_FILE")"
  fi

  local base_name
  base_name="$(basename "$PROMPT_FILE")"
  base_name="${base_name%.*}"

  # Kill existing tmux session
  if [[ "$DRY_RUN" == false ]] && tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    log_warn "Killing existing tmux session: $SESSION_NAME"
    tmux kill-session -t "$SESSION_NAME"
  fi

  log "Starting multi-loop: ${#provider_list[@]} providers"
  log "Providers: ${provider_list[*]}"
  log "Prompt: $PROMPT_FILE"
  [[ -n "$VERIFY_FILE" ]] && log "Verify: $VERIFY_FILE"
  echo "" >&2

  local first=true
  PROVIDER_PORT_OFFSET=0

  for provider in "${provider_list[@]}"; do
    provider="$(echo "$provider" | tr -d ' ')"

    # Create provider-specific prompt copy (distinct run dirs)
    local provider_prompt="${base_name}-${provider}.md"
    if [[ "$DRY_RUN" == false ]]; then
      cp "$prompt_abs" "$provider_prompt"
    fi

    # Build full command
    local full_cmd
    full_cmd="$(build_provider_command "$config" "$provider" "$provider_prompt" "$verify_abs")"

    # Wrap with banner
    local wrapped_cmd="echo '━━━ multi-loop: ${provider} ━━━'
${full_cmd}
echo ''
echo '━━━ ${provider} finished ━━━'
exec bash"

    if [[ "$DRY_RUN" == true ]]; then
      echo "=== Provider: $provider ==="
      echo "$wrapped_cmd"
      echo ""
    else
      if [[ "$first" == true ]]; then
        tmux new-session -d -s "$SESSION_NAME" -n "$provider"
        tmux send-keys -t "$SESSION_NAME:$provider" "$wrapped_cmd" Enter
        first=false
      else
        tmux new-window -t "$SESSION_NAME" -n "$provider"
        tmux send-keys -t "$SESSION_NAME:$provider" "$wrapped_cmd" Enter
      fi

      local port_msg=""
      if [[ "$WEB_MODE" == true ]] && read_provider_field "$config" "$provider" "command" | grep -q "more-loop"; then
        port_msg=" (dashboard: http://localhost:$((PORT_BASE + PROVIDER_PORT_OFFSET)))"
      fi
      log_pass "  ${provider}: launched${port_msg}"
    fi

    PROVIDER_PORT_OFFSET=$((PROVIDER_PORT_OFFSET + 1))
  done

  if [[ "$DRY_RUN" == true ]]; then
    log "Dry run complete — no tmux session created"
    return
  fi

  echo "" >&2
  log "tmux session: $SESSION_NAME"
  log "  Attach:  tmux attach -t $SESSION_NAME"
  log "  Status:  $(basename "$0") --status"
  log "  Stop:    $(basename "$0") --stop"

  # Show LAN IP for phone access
  if [[ "$WEB_MODE" == true ]]; then
    local lan_ip
    lan_ip="$(hostname -I 2>/dev/null | awk '{print $1}')" || lan_ip="<your-ip>"
    echo "" >&2
    log "Web dashboards (check from phone on same WiFi):"
    PROVIDER_PORT_OFFSET=0
    for provider in "${provider_list[@]}"; do
      provider="$(echo "$provider" | tr -d ' ')"
      if read_provider_field "$config" "$provider" "command" | grep -q "more-loop"; then
        log "  ${provider}: http://${lan_ip}:$((PORT_BASE + PROVIDER_PORT_OFFSET))"
      fi
      PROVIDER_PORT_OFFSET=$((PROVIDER_PORT_OFFSET + 1))
    done
  fi
  echo "" >&2
}

main() {
  parse_args "$@"

  if [[ "$INIT_MODE" == true ]]; then init_config; exit 0; fi
  if [[ "$STATUS_MODE" == true ]]; then show_status; exit 0; fi
  if [[ "$STOP_MODE" == true ]]; then stop_all; exit 0; fi

  launch
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
